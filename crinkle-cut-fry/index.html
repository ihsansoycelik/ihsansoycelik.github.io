<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crinkle Cut Type</title>
    <style>
        :root {
            --bg-color: #FDEE3F;
            --fry-color: #FFFFFF;
            --text-color: #000000;
            --font-family: 'Courier New', Courier, monospace;
            --ui-bg: rgba(255, 255, 255, 0.6);
            --ui-border: rgba(255, 255, 255, 0.8);
            --ui-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.15);
        }

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-color);
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* UI Control Panel */
        #ui-panel {
            position: absolute;
            bottom: 24px;
            right: 24px;
            width: 320px;
            padding: 24px;
            background: var(--ui-bg);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid var(--ui-border);
            border-radius: 18px;
            box-shadow: var(--ui-shadow);
            display: flex;
            flex-direction: column;
            gap: 16px;
            z-index: 100;
            transition: opacity 0.3s ease;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        label {
            font-size: 12px;
            font-weight: 600;
            color: #333;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        textarea {
            width: 100%;
            height: 60px;
            border-radius: 8px;
            border: 1px solid rgba(0,0,0,0.1);
            padding: 8px;
            font-family: inherit;
            font-size: 14px;
            resize: none;
            background: rgba(255,255,255,0.5);
            box-sizing: border-box;
        }

        textarea:focus {
            outline: none;
            border-color: #007AFF;
            background: #fff;
        }

        input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            background: transparent;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 20px;
            width: 20px;
            border-radius: 50%;
            background: #ffffff;
            border: 1px solid rgba(0,0,0,0.1);
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
            margin-top: -8px;
            cursor: pointer;
        }

        input[type="range"]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            background: rgba(0,0,0,0.1);
            border-radius: 2px;
        }

        .color-inputs {
            display: flex;
            justify-content: space-between;
        }

        .color-input-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
        }

        input[type="color"] {
            -webkit-appearance: none;
            border: none;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            padding: 0;
            overflow: hidden;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        input[type="color"]::-webkit-color-swatch-wrapper {
            padding: 0;
        }

        input[type="color"]::-webkit-color-swatch {
            border: none;
            border-radius: 50%;
            border: 1px solid rgba(0,0,0,0.1);
        }

        button#toggle-play {
            width: 100%;
            padding: 12px;
            background: #007AFF;
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s;
        }

        button#toggle-play:hover {
            background: #0056b3;
        }

        /* Font preload helper */
        #font-loader {
            position: absolute;
            top: -9999px;
            left: -9999px;
            font-family: 'Courier New', Courier, monospace;
            font-weight: bold;
        }

    </style>
</head>
<body>
    <div id="font-loader">LOAD</div>
    <canvas id="canvas"></canvas>

    <div id="ui-panel">
        <div class="control-group">
            <label for="text-input">Phrases (Comma Separated)</label>
            <textarea id="text-input">FRENCH, FRIES, COME FROM, BELGIUM</textarea>
        </div>

        <div class="control-group">
            <label for="speed-slider">Speed</label>
            <input type="range" id="speed-slider" min="0" max="200" value="100">
        </div>

        <div class="control-group">
            <label>Colors</label>
            <div class="color-inputs">
                <div class="color-input-wrapper">
                    <input type="color" id="bg-color-picker" value="#FDEE3F">
                    <label style="font-size: 10px;">BG</label>
                </div>
                <div class="color-input-wrapper">
                    <input type="color" id="fry-color-picker" value="#FFFFFF">
                    <label style="font-size: 10px;">Fry</label>
                </div>
                <div class="color-input-wrapper">
                    <input type="color" id="text-color-picker" value="#000000">
                    <label style="font-size: 10px;">Text</label>
                </div>
            </div>
        </div>

        <button id="toggle-play">Pause</button>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // --- State ---
        const state = {
            phrases: ["FRENCH", "FRIES", "COME FROM", "BELGIUM"],
            currentPhraseIndex: 0,
            lastSwitchTime: 0,
            isPlaying: true,
            speed: 1.0,
            colors: {
                bg: '#FDEE3F',
                fry: '#FFFFFF',
                text: '#000000'
            },
            time: 0,
            fryLength: 400, // Target length
            currentFryLength: 400, // Animated length
            fontLoaded: false
        };

        const config = {
            switchInterval: 1000,
            fryWidth: 120, // Width of the fry (cross-section width)
            fryHeight: 60, // Thickness of the fry (extrusion)
            waveAmp: 15,
            ridgeSpacing: 80, // Distance between peaks
            segmentSize: 5, // Detail level
            fontSize: 40,
            strokeWidth: 3
        };
        // Derived frequency to ensure peaks match spacing
        config.waveFreq = (Math.PI * 2) / config.ridgeSpacing;

        // --- Inputs ---
        const textInput = document.getElementById('text-input');
        const speedSlider = document.getElementById('speed-slider');
        const bgPicker = document.getElementById('bg-color-picker');
        const fryPicker = document.getElementById('fry-color-picker');
        const textPicker = document.getElementById('text-color-picker');
        const toggleBtn = document.getElementById('toggle-play');

        // Event Listeners
        textInput.addEventListener('input', (e) => {
            state.phrases = e.target.value.split(',').map(s => s.trim()).filter(s => s.length > 0);
            if (state.phrases.length === 0) state.phrases = [""];
            state.currentPhraseIndex = 0;
            state.lastSwitchTime = performance.now();
        });

        speedSlider.addEventListener('input', (e) => {
            state.speed = e.target.value / 100;
        });

        bgPicker.addEventListener('input', (e) => {
            state.colors.bg = e.target.value;
            document.body.style.backgroundColor = state.colors.bg;
        });

        fryPicker.addEventListener('input', (e) => { state.colors.fry = e.target.value; });
        textPicker.addEventListener('input', (e) => { state.colors.text = e.target.value; });

        toggleBtn.addEventListener('click', () => {
            state.isPlaying = !state.isPlaying;
            toggleBtn.textContent = state.isPlaying ? "Pause" : "Play";
        });

        // --- Math & Geometry ---

        // Isometric Projection
        // x, y, z -> screenX, screenY
        // Using standard isometric angles: X axis at 30 deg, Z axis at 150 deg (or -210).
        // Let's define:
        // +X goes Down-Right
        // +Y goes Up (Vertical) - Wait, in canvas +Y is down.
        // Let's use standard 3D coordinate system where +Y is UP. We flip at the end.
        // Iso Projection Matrix:
        // x_screen = (x - z) * cos(30)
        // y_screen = (x + z) * sin(30) - y

        function project(x, y, z) {
            const cos30 = 0.866;
            const sin30 = 0.5;

            const sx = (x - z) * cos30;
            const sy = (x + z) * sin30 - y; // -y because y is up in 3D, but down in Canvas usually.
            // If we treat y as "height", then -y moves it up on screen.

            return { x: sx, y: sy };
        }

        function getWaveY(dist, time) {
            // Use Cosine so that 0 is a Peak
            return Math.cos(dist * config.waveFreq) * config.waveAmp;
        }

        // --- Rendering ---

        function drawFry(ctx, cx, cy, length, time) {
            // Center the drawing at cx, cy

            const halfW = config.fryWidth / 2;
            const numSegments = Math.ceil(length / config.segmentSize);

            // Generate points
            // Fry lies along the diagonal X=Z line?
            // "Shape must flow diagonally from Top-Left to Bottom-Right."
            // In our iso projection:
            // +X is Down-Right. -Z is Up-Right.
            // If we increase X, we go DR. If we increase Z, we go DL.
            // To go TL to BR, we want +X and -Z? No.
            // TL to BR on screen is +ScreenX, +ScreenY.
            // +ScreenX comes from (x - z). +ScreenY comes from (x + z).
            // If x increases, sx increases, sy increases. (Down-Right).
            // If z decreases, sx increases, sy decreases. (Up-Right).
            // So pure X-axis is diagonal Down-Right.
            // So we align the fry along the X axis. Z is width. Y is height (wave).

            const pointsTopLeft = [];
            const pointsTopRight = [];
            const pointsBottomLeft = [];
            const pointsBottomRight = [];

            // We iterate along X from -length/2 to length/2
            for (let i = 0; i <= numSegments; i++) {
                const x = -length/2 + (i * config.segmentSize);
                // Wave is in Y
                const y = getWaveY(x, time);

                // Top Surface
                // Left Edge (Z = -halfW)
                // Right Edge (Z = +halfW)

                const tl = project(x, y, -halfW);
                const tr = project(x, y, halfW);

                // Bottom Surface (Y is lower)
                const bl = project(x, y - config.fryHeight, -halfW);
                const br = project(x, y - config.fryHeight, halfW);

                pointsTopLeft.push(tl);
                pointsTopRight.push(tr);
                pointsBottomLeft.push(bl);
                pointsBottomRight.push(br);
            }

            ctx.save();
            ctx.translate(cx, cy);

            ctx.lineWidth = config.strokeWidth;
            ctx.lineJoin = 'round';
            ctx.lineCap = 'round';
            ctx.strokeStyle = state.colors.text; // Black stroke as requested "Thick Black"
            ctx.fillStyle = state.colors.fry;

            // 1. Draw Bottom/Side Faces (Extrusion)
            // We need to draw the "front" faces that are visible.
            // Since we are looking from "Top", and X axis goes Down-Right.
            // Visible faces: Top, South-East (End), South-West (Side)?
            // Isometric view: usually see Top, Left, Right.
            // Our Fry is along X axis.
            // Left side (Z=-halfW) is "Back". Right side (Z=halfW) is "Front".
            // Wait, (x-z). If z is positive, x-z is smaller (Left on screen).
            // So Z=halfW is "Left" on screen? No.
            // z positive -> sx negative. So Z axis goes Left.
            // So Z=halfW is "Left/Back". Z=-halfW is "Right/Front".
            // Let's verify:
            // X=100, Z=0 -> sx=86, sy=50. (Right, Down).
            // X=0, Z=100 -> sx=-86, sy=50. (Left, Down).
            // So +Z is Left-Down. +X is Right-Down.
            // Our fry is along X.
            // So one side is at +Z (Left side), one at -Z (Right side).
            // The "Right side" (Z=-halfW) faces the viewer (Bottom-Right quadrant).
            // The "Left side" (Z=+halfW) faces away.

            // Draw "Back" / "Left" Side (Z = +halfW) - Usually hidden if solid, but maybe visible due to wave?
            // Actually, if we look from Top, we see Top.
            // If we look from South, we see Side.
            // Standard Iso looks from "Corner".
            // +X is DR, +Z is DL.
            // We see the face defined by X-axis and Vertical. That is the "-Z" face (Right side).
            // And the face defined by Z-axis and Vertical. That is the "-X" face (End cap).

            // Draw Side (Z = -halfW) - The one "facing" us roughly.
            // Wait, Z=-halfW corresponds to "Right" in project logic?
            // sx = (x - (-w)) = x + w. More positive X.
            // So Z=-halfW is the "Right" edge on screen.
            // Z=+halfW is the "Left" edge on screen.
            // Usually in Iso, the "Front-Left" and "Front-Right" faces are visible.
            // Since our fry is long along X, the long side at Z=-halfW should be visible?
            // Wait, Z axis goes DL. X axis goes DR.
            // The region between X and Z is "Down".
            // The region between -X and -Z is "Up".
            // We look from Up.
            // So we see Top.
            // Do we see the side at Z=-halfW?
            // Normal of side Z=-halfW points towards -Z (Up-Right).
            // View vector is towards origin.
            // Yes, we should see the face at Z=-halfW (Right-hand edge).

            // Draw Ribbon for Right Side (Z = -halfW)
            ctx.beginPath();
            // Trace Top Edge
            for(let i=0; i<pointsTopLeft.length; i++) {
                // Actually Z=-halfW is TopLeft in my array naming (Left/Right is confusing).
                // Let's check my project call:
                // tl = project(x, y, -halfW).
                // tr = project(x, y, halfW).
                // tl has larger sx than tr?
                // sx_tl = (x - (-w)) = x+w.
                // sx_tr = (x - w).
                // So TL is on the Right of screen. TR is on the Left of screen.
                // Okay, so "TopLeft" array is actually the Screen-Right edge.
                // "TopRight" array is the Screen-Left edge.

                // Visible Side is the Screen-Right edge (tl array).
                const p = pointsTopLeft[i];
                if (i===0) ctx.moveTo(p.x, p.y);
                else ctx.lineTo(p.x, p.y);
            }
            // Trace Down at end
            const lastTL = pointsTopLeft[pointsTopLeft.length-1];
            const lastBL = pointsBottomLeft[pointsBottomLeft.length-1];
            ctx.lineTo(lastBL.x, lastBL.y);

            // Trace Bottom Edge Backwards
            for(let i=pointsBottomLeft.length-1; i>=0; i--) {
                const p = pointsBottomLeft[i];
                ctx.lineTo(p.x, p.y);
            }
            // Close
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            // Draw End Cap (at -length/2) - The "Top-Left" end on screen.
            // X = -length/2.
            // Faces -X direction (Up-Left).
            // View vector looks from Up.
            // We might see it.
            {
                const i = 0;
                ctx.beginPath();
                ctx.moveTo(pointsTopLeft[i].x, pointsTopLeft[i].y);
                ctx.lineTo(pointsTopRight[i].x, pointsTopRight[i].y);
                ctx.lineTo(pointsBottomRight[i].x, pointsBottomRight[i].y);
                ctx.lineTo(pointsBottomLeft[i].x, pointsBottomLeft[i].y);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
            }

            // Draw Top Surface
            ctx.beginPath();
            // Edge 1 (Right on screen)
            for(let i=0; i<pointsTopLeft.length; i++) {
                const p = pointsTopLeft[i];
                if (i===0) ctx.moveTo(p.x, p.y);
                else ctx.lineTo(p.x, p.y);
            }
            // Edge 2 (Left on screen) - Connect
            ctx.lineTo(pointsTopRight[pointsTopRight.length-1].x, pointsTopRight[pointsTopRight.length-1].y);
            // Trace Edge 2 Backwards
            for(let i=pointsTopRight.length-1; i>=0; i--) {
                const p = pointsTopRight[i];
                ctx.lineTo(p.x, p.y);
            }
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            // Internal Ridges?
            // "Each letter should sit on its own 'ridge'".
            // Maybe draw lines across the top surface at intervals to show the "crinkle"?
            // If the wave is sinusoidal, we can draw lines at the valleys or peaks?
            // Let's draw transverse lines every few segments to emphasize shape.
            /*
            ctx.lineWidth = 1;
            for(let i=0; i<pointsTopLeft.length; i+=4) {
                 ctx.beginPath();
                 ctx.moveTo(pointsTopLeft[i].x, pointsTopLeft[i].y);
                 ctx.lineTo(pointsTopRight[i].x, pointsTopRight[i].y);
                 ctx.stroke();
            }
            ctx.lineWidth = config.strokeWidth;
            */

            ctx.restore();
        }

        function drawText(ctx, cx, cy, length, text) {
            if (!text) return;

            // Text Placement
            // We want to place letters along the spine.
            // We need to transform the context to match the top face.
            // Top Face: X axis (fry length) -> Down-Right (30 deg).
            // Z axis (width) -> Down-Left (150 deg).
            // Text flows along X.

            ctx.save();
            ctx.translate(cx, cy);

            ctx.font = `bold ${config.fontSize}px "${state.fontLoaded ? 'Courier New' : 'Courier'}"`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillStyle = state.colors.text;

            const numChars = text.length;

            // Ridge Alignment Logic
            // We want every letter to sit on a peak (Ridge).
            // Peaks are at multiples of config.ridgeSpacing (since we use Cosine).
            // We center the text group.
            // If even number of chars, we offset by half spacing to align with peaks.

            const step = config.ridgeSpacing;
            const totalTextLen = (numChars - 1) * step;

            // Center the group
            let startX = -totalTextLen / 2;

            // If even, shift to align with peaks (Peak at 0, S, -S...)
            // Even chars centered at 0 means -0.5S and 0.5S (Valleys).
            // Shift by 0.5S to put them at 0 and S (Peaks).
            if (numChars % 2 === 0) {
                startX += step / 2;
            }

            for (let i = 0; i < numChars; i++) {
                const char = text[i];
                const xPos = startX + (i * step);

                // Get Height at this X position
                // The letter sits on the "ridge".

                const yPos = getWaveY(xPos, 0);
                // We want to draw at 3D coord (xPos, yPos, 0).

                const p = project(xPos, yPos, 0); // Center of width (Z=0)

                ctx.save();
                ctx.translate(p.x, p.y);

                // Apply Isometric Rotation/Skew for the text
                // We want the text baseline to follow the X axis (30 deg down).
                // And the vertical of the text to follow the Z axis? No.
                // Text vertical usually points "Up" in 3D? Or "Back" along Z?
                // If text is "on top", it lies flat.
                // Baseline: Vector (1, 0, 0) -> Screen (0.866, 0.5) (approx 30 deg).
                // Up Vector: Vector (0, 0, -1) -> Screen (0.866, -0.5) (approx -30 deg).
                // So we rotate 30 degrees?
                // If we rotate 30 deg: X axis becomes horiz? No.
                // Let's use transform(a, b, c, d, e, f).
                // u (1,0) -> (0.866, 0.5) * scale
                // v (0,1) -> (0.866, -0.5) * scale (Mapping text-up to 3D Z-back)

                const scale = 1.0;
                // a = 0.866, b = 0.5
                // c = 0.866, d = -0.5 (Wait, Z is width axis, usually text height goes along width if flat?)
                // Let's try explicit transform.
                // Text U axis (Right) -> Fry X axis.
                // Text V axis (Up) -> Fry -Z axis (Across the width).
                // +X in project: (cos30, sin30) = (0.866, 0.5)
                // -Z in project: -1 * (-cos30, sin30) = (0.866, -0.5)
                // Note: project(0,0,-1) = (0.866, -0.5) approx.

                // ctx.transform(a, b, c, d, e, f)
                // a: horizontal scaling/skewing
                // b: horizontal skewing
                // c: vertical skewing
                // d: vertical scaling

                ctx.transform(0.866, 0.5, 0.866, -0.5, 0, 0);

                // Correction for font aspect?
                // Just drawing it.
                ctx.fillText(char, 0, 0);

                ctx.restore();
            }

            ctx.restore();
        }

        // --- Loop ---

        function update(dt) {
            if (!state.isPlaying) return;
            state.time += dt * state.speed;

            // Word Cycle
            const now = performance.now();
            if (now - state.lastSwitchTime > (config.switchInterval / state.speed)) {
                state.currentPhraseIndex = (state.currentPhraseIndex + 1) % state.phrases.length;
                state.lastSwitchTime = now;
            }

            // Animate Fry Length
            const currentText = state.phrases[state.currentPhraseIndex];
            // Target length based on ridge spacing + padding
            const targetLen = Math.max(300, (currentText.length * config.ridgeSpacing) + 160);

            // Lerp
            const lerpSpeed = 0.1;
            state.currentFryLength += (targetLen - state.currentFryLength) * lerpSpeed;
        }

        function draw() {
            // Clear
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Center of screen
            const cx = canvas.width / 2;
            const cy = canvas.height / 2;

            drawFry(ctx, cx, cy, state.currentFryLength, state.time);
            drawText(ctx, cx, cy, state.currentFryLength, state.phrases[state.currentPhraseIndex]);
        }

        function loop() {
            update(16); // assume 60fps for simplicity of dt
            draw();
            requestAnimationFrame(loop);
        }

        // Init
        function resize() {
            // Handle retina
            const dpr = window.devicePixelRatio || 1;
            canvas.width = window.innerWidth * dpr;
            canvas.height = window.innerHeight * dpr;
            ctx.scale(dpr, dpr);
        }
        window.addEventListener('resize', resize);
        resize();

        // Wait for font
        document.fonts.ready.then(() => {
            state.fontLoaded = true;
        });

        loop();

    </script>
</body>
</html>
